<?php

namespace AppBundle\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\Query\Expr;

/**
 * UserRepository
 *
 * This class was generated by the PhpStorm "Php Annotations" Plugin. Add your own custom
 * repository methods below.
 */
class UserRepository extends EntityRepository
{
    private $tableObjectName = 'AppBundle:User';
    /**
     * @param array $get
     * @param bool $flag
     * @return array|\Doctrine\ORM\Query
     */
    public function ajaxTable(array $get, $flag = false)
    {
        /* Indexed column (used for fast and accurate table cardinality) */
        $alias = 'a';
        /* DB table to use */
        $tableObjectName = 'AppBundle:User';
        /**
         * Set to default
         */
        if (!isset($get['columnss']) || empty($get['columnss'])) {
            $get['columnss'] = array('id');
        }
        $aColumns = array();
        foreach ($get['columnss'] as $value) {
            $aColumns[] = $alias.'.'.$value;
        }
        $cb = $this->getEntityManager()
            ->getRepository($tableObjectName)
            ->createQueryBuilder($alias)
            ->select(str_replace(" , ", " ", implode(", ", $aColumns)));
        if (isset($get['start']) && $get['length'] != '-1') {
            $cb->setFirstResult((int)$get['start'])
                ->setMaxResults((int)$get['length']);
        }
        /*
         * Ordering
         */
        if (isset($get['order'])) {
            for ($i = 0; $i < intval($get['order']); $i++) {
                    $cb->orderBy($aColumns[(int)$get['order'][$i]['column']], $get['order'][$i]['dir']);
            }
        }
        /*
           * Filtering
           * NOTE this does not match the built-in DataTables filtering which does it
           * word by word on any field. It's possible to do here, but concerned about efficiency
           * on very large tables, and MySQL's regex functionality is very limited
           */
        if (isset($get['search']) && $get['search']['value'] != '') {
            $aLike = array();
            for ($i = 0; $i < count($get['columns']) ; $i++) {
//                dump($get['columns'][$i]);
                if (isset($get['columns'][$i]['searchable']) && $get['columns'][$i]['searchable'] == "true") {
                    if($i != 2 || ($get['search']['value'] != "true" && $get['search']['value'] != "false")) {
                        $aLike[] = $cb->expr()->like($aColumns[$i], '\'%'.$get['search']['value'].'%\'');
                    } else {
                        if ($get['search']['value'] == "true") {
                            $ser  = 1;
                        } else {
                            $ser  = 0;
                        }
                        $aLike[] = $cb->expr()->eq($aColumns[$i], $ser);
                    }
                }
            }
            if (count($aLike) > 0) {
                $cb->andWhere(new Expr\Orx($aLike));
            } else {
                unset($aLike);
            }
        }
        /*
         * SQL queries
         * Get data to display
         */
        $query = $cb->getQuery();

//        dump($query);
        if ($flag) {
            return $query;
        } else {
            return $query->getResult();
        }
    }

    public function getFilteredCount(array $get)
    {
        /* Indexed column (used for fast and accurate table cardinality) */
        $alias = 'a';

        /* DB table to use */
        $tableObjectName = 'AppBundle:User';

        /**
         * Set to default
         */
        if (!isset($get['columnss']) || empty($get['columnss'])) {
            $get['columnss'] = array('id');
        }
        $aColumns = array();
        foreach ($get['columnss'] as $value) {
            $aColumns[] = $alias.'.'.$value;
        }

        $cb = $this->getEntityManager()
            ->getRepository($tableObjectName)
            ->createQueryBuilder($alias)
            ->select("count(a.id)");

        /*
        * Filtering
        * NOTE this does not match the built-in DataTables filtering which does it
        * word by word on any field. It's possible to do here, but concerned about efficiency
        * on very large tables, and MySQL's regex functionality is very limited
        */
        if (isset($get['search']) && $get['search']['value'] != '') {
            $aLike = array();
            for ($i = 0; $i < count($get['columns']) ; $i++) {
//                dump($get['columns'][$i]);
                if (isset($get['columns'][$i]['searchable']) && $get['columns'][$i]['searchable'] == "true") {
                    if($i != 2 || ($get['search']['value'] != "true" && $get['search']['value'] != "false")) {
                        $aLike[] = $cb->expr()->like($aColumns[$i], '\'%'.$get['search']['value'].'%\'');
                    } else {
                        if ($get['search']['value'] == "true") {
                            $ser  = 1;
                        } else {
                            $ser  = 0;
                        }
                        $aLike[] = $cb->expr()->eq($aColumns[$i], $ser);
                    }
                }
            }
            if (count($aLike) > 0) {
                $cb->andWhere(new Expr\Orx($aLike));
            } else {
                unset($aLike);
            }
        }

        /*
         * SQL queries
         * Get data to display
         */
        $query = $cb->getQuery();
        $aResultTotal = $query->getResult();
        return $aResultTotal[0][1];
    }

    /**
     * @return int
     */
    public function getCount()
    {
        $aResultTotal = $this->getEntityManager()
            ->createQuery('SELECT COUNT(a) FROM AppBundle:User a')
            ->setMaxResults(1)
            ->getResult();

        return $aResultTotal[0][1];
    }
}